- name: record
  iml: |
    type point = { x: int; y: int }

    let distance_category = fun p ->
      let sum = p.x + p.y in
      if sum < 0 then "negative"
      else if sum = 0 then "origin"
      else "positive"
  req_kwargs:
    names:
      - point

- name: tuple_two_int
  iml: |
    type two_int = int * int
  req_kwargs:
    names:
      - two_int

- name: variant_simple
  iml: |
    type color = Red | Green | Blue

    let color_value = fun c ->
      match c with
      | Red -> 1
      | Green -> 2
      | Blue -> 3
  req_kwargs:
    names:
      - color

- name: variant_with_payload
  iml: |
    type shape =
    | Point
    | Circle of int
    | Rectangle of int * int
    | Triangle of {a: int; b: int; c: int}
  req_kwargs:
    names:
      - shape
  expected_python_code: |
    @dataclass
    class Point:
        pass

    @dataclass
    class Circle:
        arg0: int  # anonymous field

    @dataclass
    class Rectangle:
        arg0: int
        arg1: int

    @dataclass
    class Triangle:
        a: int
        b: int
        c: int

    # Note: we keep the original name (lower case)
    shape = Point | Circle | Rectangle | Triangle

- name: variant_with_composite_payload
  iml: |
    type shape2 =
    | Circle of int option
  req_kwargs:
    names:
      - shape2

- name: variant_two
  iml: |
    type rect =
    | Rectangle of int * int
    | Square of int

    type shape =
    | Circle of int
    | Polygon of rect
  req_kwargs:
    names:
      - shape

- name: variant_poly
  iml: |
    type 'a shape_poly =
    | Point
    | Circle of 'a
    | Rectangle of 'a * 'a
    | Triangle of {a: 'a; b: 'a; c: 'a}
  req_kwargs:
    names:
      - shape_poly
  expected_python_code: |
    from dataclasses import dataclass
    from typing import Generic, TypeVar

    T = TypeVar('T')

    @dataclass
    class Point:
        pass

    @dataclass
    class Circle(Generic[T]):
        arg0: T

    @dataclass
    class Rectangle(Generic[T]):
        arg0: T
        arg1: T

    @dataclass
    class Triangle(Generic[T]):
        a: T
        b: T
        c: T

    # type shape_poly[T] = Point | Circle[T] | Rectangle[T] | Triangle[T]
    shape_poly = Point | Circle[T] | Rectangle[T] | Triangle[T]

- name: variant_poly_two_var
  iml: |
    type ('a, 'b) container =
      | Empty
      | Single of 'a
      | Pair of 'a * 'b
      | Labeled of { key: 'a; value: 'b }
      | Multi of 'a list * 'b list
  req_kwargs:
    names:
      - container
  expected_python_code: |
    @dataclass
    class Empty:
        pass

    @dataclass
    class Single[A]:
        arg0: A

    @dataclass
    class Pair[A, B]:
        arg0: A
        arg1: B

    @dataclass
    class Labeled[A, B]:
        key: A
        value: B

    @dataclass
    class Multi[A, B]:
        arg0: list[A]
        arg1: list[B]

    # type Container[A, B] = Empty | Single[A] | Pair[A, B] | Labeled[A, B] | Multi[A, B]
    Container = Empty | Single[A] | Pair[A, B] | Labeled[A, B] | Multi[A, B]

- name: nested_generics
  iml: |
    type 'a identity = Identity of 'a

    type 'a maybe =
      | Just of 'a
      | Nothing

    type 'a validated =
      | Valid of 'a
      | Invalid of string

    type 'a tagged = {
      value : 'a;
      tag : string
    }

    type my_ty =
      | My_ty of int identity maybe validated tagged
  req_kwargs:
    names:
      - my_ty
  expected_python_code: |
    @dataclass
    class my_ty:
        arg0: tagged[validated[maybe[identity[int]]]]

- name: variant_recursive
  iml: |
    type tree =
      | Leaf of int
      | Node of tree * tree ;;
  req_kwargs:
    names:
      - tree
  expected_python_code: |
    @dataclass
    class Leaf:
        arg0: int

    @dataclass
    class Node:
        arg0: tree
        arg1: tree

    tree = Leaf | Node

- name: GADT_monomorphic
  iml: |
    type _ expr =
      | Int: int -> int expr
      | Add: int expr * int expr -> int expr
  req_kwargs:
    names:
      - expr

- name: real_and_option
  iml: |
    type my_ty = {
      x: real;
      y: int option;
      z: int;
    }
  req_kwargs:
    names:
      - my_ty

- name: function
  iml: |
    type direction = North | South | East | West

    type position = { x: int; y: int; z: real }

    type movement =
      | Stay of position
      | Move of position * direction

    let move = fun w ->
      match w with
      | Stay p -> p
      | Move (p, d) ->
        let x, y, z = p.x, p.y, p.z in
        let x, y, z =
          match d with
          | North -> (x, y+1, z)
          | South -> (x, y-1, z)
          | East -> (x+1, y, z)
          | West -> (x-1, y, z)
        in
        { x; y; z }
  req_kwargs:
    names:
      - move

---
- name: basic
  iml: |
    let g = fun x -> x + 1

    let f = fun x -> if x > 0 then x + 2 else g x
  decomp_kwargs:
    name: f
    prune: true

- name: primitive_int
  iml: |
    let classify_number = fun x ->
      if x < 0 then -1
      else if x = 0 then 0
      else 1
  decomp_kwargs:
    name: classify_number
    prune: true

- name: primitive_bool
  iml: |
    let bool_logic = fun a b ->
      if a && b then 1
      else if a || b then 2
      else 0
  decomp_kwargs:
    name: bool_logic
    prune: true

- name: primitive_real
  iml: |
    let classify_temp = fun temp ->
      if temp < 0.0 then "freezing"
      else if temp < 20.0 then "cold"
      else if temp < 30.0 then "warm"
      else "hot"
  decomp_kwargs:
    name: classify_temp
    prune: true

- name: composite_record
  iml: |
    type point = { x: int; y: int }

    let distance_category = fun p ->
      let sum = p.x + p.y in
      if sum < 0 then "negative"
      else if sum = 0 then "origin"
      else "positive"
  decomp_kwargs:
    name: distance_category
    prune: true

- name: composite_tuple
  iml: |
    let tuple_compare = fun (a, b) ->
      if a > b then a - b
      else if a = b then 0
      else b - a
  decomp_kwargs:
    name: tuple_compare
    prune: true

- name: variant_simple
  iml: |
    type color = Red | Green | Blue

    let color_value = fun c ->
      match c with
      | Red -> 1
      | Green -> 2
      | Blue -> 3
  decomp_kwargs:
    name: color_value
    prune: true

- name: variant_with_data
  iml: |
    type shape =
      | Circle of int
      | Rectangle of int * int

    let area = fun s ->
      match s with
      | Circle r -> r * r
      | Rectangle (w, h) -> w * h
  decomp_kwargs:
    name: area
    prune: true

- name: nested_conditions
  iml: |
    let nested_check = fun x y ->
      if x > 0 then
        if y > 0 then x + y
        else x - y
      else
        if y > 0 then y - x
        else -(x + y)
  decomp_kwargs:
    name: nested_check
    prune: true

- name: multiple_parameters
  iml: |
    let calculate = fun a b c ->
      if a > b && b > c then a + b + c
      else if a = b then a * c
      else if b = c then b * a
      else 0
  decomp_kwargs:
    name: calculate
    prune: true

- name: list_operations
  iml: |
    let list_check = fun xs ->
      match xs with
      | [] -> 0
      | [x] -> x
      | x :: y :: _ -> x + y
  decomp_kwargs:
    name: list_check
    prune: true

- name: option_type
  iml: |
    let option_value = fun opt ->
      match opt with
      | None -> 0
      | Some x -> if x > 0 then x else -x
  decomp_kwargs:
    name: option_value
    prune: true

- name: with_basis
  iml: |
    let helper = fun x -> x * x

    let compute = fun x ->
      if x > 0 then helper x
      else helper (-x)
  decomp_kwargs:
    name: compute
    prune: true
    basis: [helper]

- name: complex_variant_record
  iml: |
    type status = Active | Inactive

    type user = {
      id: int;
      active: status;
    }

    let process_user = fun u ->
      match u.active with
      | Active -> if u.id > 0 then u.id else 0
      | Inactive -> -1
  decomp_kwargs:
    name: process_user
    prune: true

- name: with_guards
  iml: |
    let classify = fun x y ->
      if x > 0 && y > 0 && x > y then 1
      else if x > 0 && y > 0 && x < y then 2
      else if x > 0 && y > 0 then 3
      else 0
  decomp_kwargs:
    name: classify
    prune: true
