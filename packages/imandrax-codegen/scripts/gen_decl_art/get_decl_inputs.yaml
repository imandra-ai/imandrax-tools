- name: record
  iml: |
    type point = { x: int; y: int }

    let distance_category = fun p ->
      let sum = p.x + p.y in
      if sum < 0 then "negative"
      else if sum = 0 then "origin"
      else "positive"
  req_kwargs:
    names:
      - point

- name: tuple_two_int
  iml: |
    type two_int = int * int
  req_kwargs:
    names:
      - two_int

- name: tuple_two_int
  iml: |
    type two_int = int * int

    let diff: two_int -> int = fun (a, b) -> a - b
  req_kwargs:
    names:
      - two_int

- name: variant_simple
  iml: |
    type color = Red | Green | Blue

    let color_value = fun c ->
      match c with
      | Red -> 1
      | Green -> 2
      | Blue -> 3
  req_kwargs:
    names:
      - color

- name: variant_with_payload
  iml: |
    type shape =
      | Circle of int
      | Rectangle of int * int

    let area = fun s ->
      match s with
      | Circle r -> r * r
      | Rectangle (w, h) -> w * h
  req_kwargs:
    names:
      - shape

- name: variant_with_multiple_payloads
  iml: |
    type shape =
      | Circle of float
      | Rectangle of float * float
      | Triangle of { base: float; height: float } ;;
  req_kwargs:
    names:
      - shape

- name: variant_recursive
  iml: |
    type tree =
      | Leaf of int
      | Node of tree * tree ;;
  req_kwargs:
    names:
      - tree

- name: variant_polymorphic
  iml: |
    type 'a expr =
      | Int of int
      | Add of 'a expr * 'a expr
  req_kwargs:
    names:
      - expr

- name: GADT_monomorphic
  iml: |
    type _ expr =
      | Int: int -> int expr
      | Add: int expr * int expr -> int expr
  req_kwargs:
    names:
      - expr

# - name: polymorphic?

---
- name: basic
  iml: |
    let g = fun x -> x + 1

    let f = fun x -> if x > 0 then x + 2 else g x
  decomp_kwargs:
    name: f
    prune: true

- name: primitive_int
  iml: |
    let classify_number = fun x ->
      if x < 0 then -1
      else if x = 0 then 0
      else 1
  decomp_kwargs:
    name: classify_number
    prune: true

- name: primitive_bool
  iml: |
    let bool_logic = fun a b ->
      if a && b then 1
      else if a || b then 2
      else 0
  decomp_kwargs:
    name: bool_logic
    prune: true

- name: primitive_real
  iml: |
    let classify_temp = fun temp ->
      if temp < 0.0 then "freezing"
      else if temp < 20.0 then "cold"
      else if temp < 30.0 then "warm"
      else "hot"
  decomp_kwargs:
    name: classify_temp
    prune: true

- name: composite_record
  iml: |
    type point = { x: int; y: int }

    let distance_category = fun p ->
      let sum = p.x + p.y in
      if sum < 0 then "negative"
      else if sum = 0 then "origin"
      else "positive"
  decomp_kwargs:
    name: distance_category
    prune: true

- name: composite_tuple
  iml: |
    let tuple_compare = fun (a, b) ->
      if a > b then a - b
      else if a = b then 0
      else b - a
  decomp_kwargs:
    name: tuple_compare
    prune: true

- name: variant_simple
  iml: |
    type color = Red | Green | Blue

    let color_value = fun c ->
      match c with
      | Red -> 1
      | Green -> 2
      | Blue -> 3
  decomp_kwargs:
    name: color_value
    prune: true

- name: variant_with_data
  iml: |
    type shape =
      | Circle of int
      | Rectangle of int * int

    let area = fun s ->
      match s with
      | Circle r -> r * r
      | Rectangle (w, h) -> w * h
  decomp_kwargs:
    name: area
    prune: true

- name: nested_conditions
  iml: |
    let nested_check = fun x y ->
      if x > 0 then
        if y > 0 then x + y
        else x - y
      else
        if y > 0 then y - x
        else -(x + y)
  decomp_kwargs:
    name: nested_check
    prune: true

- name: multiple_parameters
  iml: |
    let calculate = fun a b c ->
      if a > b && b > c then a + b + c
      else if a = b then a * c
      else if b = c then b * a
      else 0
  decomp_kwargs:
    name: calculate
    prune: true

- name: list_operations
  iml: |
    let list_check = fun xs ->
      match xs with
      | [] -> 0
      | [x] -> x
      | x :: y :: _ -> x + y
  decomp_kwargs:
    name: list_check
    prune: true

- name: option_type
  iml: |
    let option_value = fun opt ->
      match opt with
      | None -> 0
      | Some x -> if x > 0 then x else -x
  decomp_kwargs:
    name: option_value
    prune: true

- name: with_basis
  iml: |
    let helper = fun x -> x * x

    let compute = fun x ->
      if x > 0 then helper x
      else helper (-x)
  decomp_kwargs:
    name: compute
    prune: true
    basis: [helper]

- name: complex_variant_record
  iml: |
    type status = Active | Inactive

    type user = {
      id: int;
      active: status;
    }

    let process_user = fun u ->
      match u.active with
      | Active -> if u.id > 0 then u.id else 0
      | Inactive -> -1
  decomp_kwargs:
    name: process_user
    prune: true

- name: with_guards
  iml: |
    let classify = fun x y ->
      if x > 0 && y > 0 && x > y then 1
      else if x > 0 && y > 0 && x < y then 2
      else if x > 0 && y > 0 then 3
      else 0
  decomp_kwargs:
    name: classify
    prune: true
